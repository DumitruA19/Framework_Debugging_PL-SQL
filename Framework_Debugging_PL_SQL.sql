/*********** Framework de Debugging  ***********/
/********************************************************************************
*  Nume pachet        : debug_utils
*  Nume tabele        : debug_log , debug_settings
*  Nume procedură     : adjust_salaries
*  Nume proceduri incluse in pachet:
*                       log_proc_start,
*                       log_proc_end,
*                       enable_debug,
                      disable_debug,
                        log_msg,
                        log_variable,
                        log_error
   Nume functie inclusa in pachet:
                        is_debug_on -verificam daca modul dedebugging este activ in aplicatie
                        get_max_column_value - calculam valoarea maxima a coloanei 
*                        
*  Descriere          : Realizarea unui framework modular de depanare pentru PL/SQL
*                       destinat monitorizarii, urmaririi si diagnosticarii erorilor
*                       si fluxurilor de executie in aplicatii de dimensiuni medii si mari
*                       Acest framework de debug este realizat pentru a automatiza procesul de debug
*                       prin utilizarea unei variabile ce preia numele aplicatiei( baza de date pe care se face debug)
                        pentru a usura intreg procesul
*  Variabile si parametri:  
*   p_app_name        - numele aplicatiei pentru care se face debug ex HR_APP
*   is_debug_on       - variabila pentru activarea debug-ului
*
*
* Autor              : Iroftei Dumitru Andrei
* Data creării       : 18.06.2025
* Data modificarii   : 20.06.2025 adaugarea functiei pentru a calcula valoarea maxima in functie de tipul coloanei
********************************************************************************/
-- 1. Create the debug_log table
CREATE TABLE debug_log (
    log_id      NUMBER
        GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
    log_time    TIMESTAMP DEFAULT systimestamp,
    module_name VARCHAR2(100),
    line_no     NUMBER,
    log_level   VARCHAR2(10),
    log_message VARCHAR2(4000),
    session_id  VARCHAR2(50) DEFAULT sys_context('USERENV', 'SESSIONID'),
    username    VARCHAR2(30) DEFAULT sys_context('USERENV', 'SESSION_USER')
);

-- 2. Create the debug_settings table
CREATE TABLE debug_settings (
    setting_id  NUMBER
        GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
    app_name    VARCHAR2(100) NOT NULL,
    is_debug_on CHAR(3) DEFAULT 'NO',
    CONSTRAINT chk_debug_flag CHECK ( is_debug_on IN ( 'YES', 'NO' ) ),
    CONSTRAINT uq_app_name UNIQUE ( app_name )
);

-- 3. Inseram date in tabelulde debug_setting( aici avem aplicatia pe care lucram HR)
INSERT INTO debug_settings (
    app_name,
    is_debug_on
) VALUES ( 'HR_APP',
           'YES' );

COMMIT;
-- 4. Cream un VARRAY Type pentru nivelurile de log
CREATE OR REPLACE TYPE log_level_array IS
    VARRAY(5) OF VARCHAR2(10);
/

-- 4.Cream pachetul debug_utils si definim nivelurile de log
CREATE OR REPLACE PACKAGE debug_utils AS
   g_log_levels log_level_array := log_level_array('DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL');

    PROCEDURE log_proc_start(p_app_name VARCHAR2);
    PROCEDURE log_proc_end(p_app_name VARCHAR2);
    PROCEDURE enable_debug(p_app_name VARCHAR2);
    PROCEDURE disable_debug(p_app_name VARCHAR2);

    PROCEDURE log_msg(p_app_name VARCHAR2, p_message VARCHAR2, p_level VARCHAR2 := 'INFO');
    PROCEDURE log_error(p_app_name VARCHAR2, p_proc_name VARCHAR2, p_err VARCHAR2);
    PROCEDURE log_variable(p_app_name VARCHAR2, p_name VARCHAR2, p_value VARCHAR2, p_level VARCHAR2);
    FUNCTION is_debug_on(p_app_name VARCHAR2) RETURN BOOLEAN;
    FUNCTION get_max_column_value(p_table_name VARCHAR2, p_column_name VARCHAR2) RETURN NUMBER;

END debug_utils;
/



-- 6. Cream debug_utils package body
CREATE OR REPLACE PACKAGE BODY debug_utils AS
/*#########Functie pentru a verifica daca debuggingul este activ#########*/
    FUNCTION is_debug_on(p_app_name VARCHAR2) RETURN BOOLEAN IS
        v_flag CHAR(3);
    BEGIN
    g_log_levels := log_level_array('DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL');
        SELECT is_debug_on INTO v_flag
        FROM debug_settings
        WHERE app_name = p_app_name AND ROWNUM = 1;

        RETURN v_flag = 'YES';
    EXCEPTION
        WHEN no_data_found THEN
            RETURN FALSE;
    END;
/*###Functie pentru a calcula automat valoare maxima pe care o admite coloana #####*/
        FUNCTION get_max_column_value(p_table_name VARCHAR2, p_column_name VARCHAR2) RETURN NUMBER IS
        v_precision  NUMBER;
        v_scale      NUMBER;
        v_max_value  NUMBER;
    BEGIN
        SELECT data_precision, data_scale
        INTO v_precision, v_scale
        FROM user_tab_columns
        WHERE table_name = UPPER(p_table_name)
          AND column_name = UPPER(p_column_name);
    
        v_max_value := POWER(10, v_precision - v_scale) - POWER(10, -v_scale);
    
        RETURN v_max_value;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Dacă nu e găsită coloana, returnăm NULL
            RETURN NULL;
        WHEN OTHERS THEN
            -- Logging pentru alte erori
            log_error('SYSTEM', 'get_max_column_value', SQLERRM);
            RETURN NULL;
    END;
/*###########Procedura pentru a activa debuggingul#############*/
    PROCEDURE enable_debug(p_app_name VARCHAR2) IS
    BEGIN
        UPDATE debug_settings
        SET is_debug_on = 'YES'
        WHERE app_name = p_app_name;
        COMMIT;
    END;
    
/*###########Procedura pentru a deactiva debuggingul#############*/
    PROCEDURE disable_debug(p_app_name VARCHAR2) IS
    BEGIN
        UPDATE debug_settings
        SET is_debug_on = 'NO'
        WHERE app_name = p_app_name;
        COMMIT;
    END;
/*#########Procedura log_msg saleaza un mesaj de log in tabel cu informatii despre modul, linie si nivel##########*/
    PROCEDURE log_msg(p_app_name VARCHAR2, p_message VARCHAR2, p_level VARCHAR2 := 'INFO') IS
        v_module   VARCHAR2(100);
        v_stack    VARCHAR2(4000);
        v_line     NUMBER := NULL;
        v_line_str VARCHAR2(100);
    BEGIN
        IF is_debug_on(p_app_name)
        OR upper(p_level) IN (g_log_levels(4), g_log_levels(5)) THEN
            BEGIN
                v_stack := dbms_utility.format_call_stack;

                v_module := regexp_substr(v_stack, '(procedure|function|package body)\s+[A-Z0-9_\.]+', 1, 1);
                v_module := regexp_replace(v_module, '^(procedure|function|package body)\s+', '');

                IF v_module IS NULL OR v_module = '' THEN
                    v_module := regexp_substr(v_stack, 'anonymous block', 1, 1);
                END IF;

                IF v_module IS NULL OR v_module = '' THEN
                    v_module := 'unknown_module';
                END IF;

                v_line_str := regexp_substr(v_stack, '[[:space:]]+[0-9]+[[:space:]]+', 1, 1);
                IF v_line_str IS NOT NULL THEN
                    BEGIN
                        v_line := TO_NUMBER(TRIM(v_line_str));
                    EXCEPTION
                        WHEN value_error THEN
                            v_line := NULL;
                    END;
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    v_module := 'logmsg_error';
                    v_line := NULL;
            END;

            INSERT INTO debug_log (
                module_name, line_no, log_message, log_level
            ) VALUES (
                v_module, v_line, p_message, UPPER(p_level)
            );
        END IF;
    END;
    
/*##########Procedura log_error inregistreaza un mesaj de eroarepentru o procedura data , folosind nivelul ERROR#########*/
    PROCEDURE log_error(p_app_name VARCHAR2, p_proc_name VARCHAR2, p_err VARCHAR2) IS
        v_full_message VARCHAR2(4000);
    BEGIN
        v_full_message := 'Error in ' || p_proc_name || ': ' || substr(p_err, 1, 3800);
        BEGIN
            log_msg(p_app_name, v_full_message, g_log_levels(4));
        EXCEPTION
            WHEN OTHERS THEN
                INSERT INTO debug_log (
                    module_name, line_no, log_message, log_level
                ) VALUES (
                    'log_error_fallback', NULL, v_full_message, g_log_levels(4)
                );
        END;
    END;
    
/*#######Procedura log_variable inregistreaza valoare unei variabile cu nivelul de log specificat #########*/
    PROCEDURE log_variable(p_app_name VARCHAR2, p_name VARCHAR2, p_value VARCHAR2, p_level VARCHAR2) IS
    BEGIN
        log_msg(p_app_name, 'VAR ' || p_name || ' = ' || p_value, p_level);
    END;

/*#########Procedura log_proc_start salveaza inceputul unei proceduri extragand automat numele acesteia in call stack############*/
    PROCEDURE log_proc_start(p_app_name VARCHAR2) IS
        v_stack     VARCHAR2(4000);
        v_proc_name VARCHAR2(100);
    BEGIN
        IF is_debug_on(p_app_name) THEN
            v_stack := dbms_utility.format_call_stack;
            v_proc_name := regexp_substr(v_stack, 'procedure\s+[A-Z0-9_\.]+', 1, 1);
            v_proc_name := replace(v_proc_name, 'procedure ', '');

            IF v_proc_name IS NULL THEN
                v_proc_name := 'unknown_proc';
            END IF;

            DBMS_APPLICATION_INFO.SET_MODULE(v_proc_name, NULL);
            log_msg(p_app_name, 'START procedure ' || v_proc_name, g_log_levels(2));
        END IF;
    END;

/*#########Procedura log_proc_end salveaza inceputul unei proceduri extragand automat numele acesteia in call stack############*/
    PROCEDURE log_proc_end(p_app_name VARCHAR2) IS
        v_stack     VARCHAR2(4000);
        v_proc_name VARCHAR2(100);
    BEGIN
        IF is_debug_on(p_app_name) THEN
            v_stack := dbms_utility.format_call_stack;
            v_proc_name := regexp_substr(v_stack, 'procedure\s+[A-Z0-9_\.]+', 1, 1);
            v_proc_name := replace(v_proc_name, 'procedure ', '');

            IF v_proc_name IS NULL THEN
                v_proc_name := 'unknown_proc';
            END IF;

            log_msg(p_app_name, 'END procedure ' || v_proc_name, g_log_levels(2));
        END IF;
    END;

END debug_utils;
/


/*#################### Activarea debugg-ului@@@@@@@@@@@@@@@@@@*/
BEGIN
    debug_utils.enable_debug('HR_APP');
END;
/
/*#################### Dezactivarea debugg-ului@@@@@@@@@@@@@@@@@@*/
BEGIN
    debug_utils.disable_debug('HR_APP');
END;
/
/*########### Procedura pentru ajustarea salariului in functie de comision ############*/
CREATE OR REPLACE PROCEDURE adjust_salaries (
    p_app_name VARCHAR2
)
IS
    -- Cursor pentru toți angajații
    CURSOR emp_cur IS
        SELECT
            employee_id,
            salary,
            commission_pct
        FROM
            employees;

 /*****Calcula valoare bruta a salariului inaite de rotunjire*********/
    v_calc        NUMBER(30, 10);         -- Valori intermediare pot fi foarte mari

/*****Variabila ce contine noul salariu rotunjit cu acelasi tip de sate ca si coloana Salary*************/
   v_new_salary employees.salary%TYPE;
    
/*****Apeleaza o functie din pachetul debug_utils care citeste metadatele tabelei, precizia si scala pentru coloana salary*******/
    v_max_salary  NUMBER := debug_utils.get_max_column_value('EMPLOYEES', 'SALARY');
    
/*****Pragul de avertizare peste care salariul il atinge 90% din maxim ***************/
    v_warn_threshold NUMBER := v_max_salary * 0.9;
    
/*****Pragul peste care se considera salariul ca este aberant*************/
    v_fatal_threshold NUMBER := v_max_salary * 0.99; 

BEGIN
    debug_utils.log_proc_start(p_app_name);

    FOR emp IN emp_cur LOOP
        -- DEBUG: variabile brute
        debug_utils.log_variable(p_app_name, 'employee_id', TO_CHAR(emp.employee_id), debug_utils.g_log_levels(1));
        debug_utils.log_variable(p_app_name, 'old salary', TO_CHAR(emp.salary), debug_utils.g_log_levels(1));
        debug_utils.log_variable(p_app_name, 'commission_pct', TO_CHAR(emp.commission_pct), debug_utils.g_log_levels(1));

        -- Calcul salariu
        IF emp.commission_pct IS NOT NULL THEN
            v_calc := emp.salary * (1 + emp.commission_pct);
        ELSE
            v_calc := emp.salary * 1.02;
            debug_utils.log_msg(
                p_app_name,
                'Default 2% applied to employee_id = ' || emp.employee_id,
                debug_utils.g_log_levels(2)  -- INFO
            );
        END IF;

        -- Rotunjire și asigurare în intervalul maxim
        v_new_salary := ROUND(LEAST(v_calc, v_max_salary), 4);

        -- DEBUG calculat
        debug_utils.log_msg(
            p_app_name,
            'Calculated new_salary for employee_id = ' || emp.employee_id || ' → ' || TO_CHAR(v_new_salary),
            debug_utils.g_log_levels(1)
        );

        -- WARN: salariu apropiat de limită
        IF v_new_salary BETWEEN v_warn_threshold AND v_max_salary THEN
            debug_utils.log_msg(
                p_app_name,
                'WARNING: salary approaching threshold for employee_id = ' || emp.employee_id || ' → ' || TO_CHAR(v_new_salary),
                debug_utils.g_log_levels(3)
            );
        END IF;

        -- ERROR: depășire limită absolută
        IF v_new_salary > v_max_salary THEN
            debug_utils.log_msg(
                p_app_name,
                'SALARY TOO LARGE for employee_id = ' || emp.employee_id || 
                ' → attempted value = ' || TO_CHAR(v_new_salary),
                debug_utils.g_log_levels(4)
            );

        -- FATAL: salariu anormal
        ELSIF v_new_salary > v_fatal_threshold THEN
            debug_utils.log_msg(
                p_app_name,
                'FATAL: Abnormal salary for employee_id = ' || emp.employee_id || 
                ' → ' || TO_CHAR(v_new_salary),
                debug_utils.g_log_levels(5)
            );
            RAISE_APPLICATION_ERROR(-20001, 'Blocare: salariu peste limita absolută.');

        -- OK: se poate aplica modificarea
        ELSE
            UPDATE employees
            SET salary = v_new_salary
            WHERE employee_id = emp.employee_id;
        END IF;
    END LOOP;

    debug_utils.log_proc_end(p_app_name);

EXCEPTION
    WHEN OTHERS THEN
        debug_utils.log_msg(p_app_name, 'EXCEPTION: v_calc=' || TO_CHAR(v_calc), debug_utils.g_log_levels(4));
        debug_utils.log_msg(p_app_name, 'EXCEPTION: v_new_salary=' || TO_CHAR(v_new_salary), debug_utils.g_log_levels(4));
        debug_utils.log_error(p_app_name, 'adjust_salaries', SQLERRM);
        RAISE;
END;
/

/********Apelam manual Procedura adjust_salaries************/
BEGIN
    adjust_salaries('HR_APP');
END;
/
select *from employees

SELECT  * FROM debug_log
ORDER BY  log_time DESC;

delete from debug_log
/*******Alte erori generate manual pentru a vedea daca sunt inregistrate********/
BEGIN
    debug_utils.log_msg(
        p_app_name => 'HR_APP',
        p_message  => 'WARN: Salariu sub pragul recomandat (sub 1000).',
        p_level    => debug_utils.g_log_levels(3)  -- WARN
    );
END;
/
BEGIN
    debug_utils.log_msg(
        p_app_name => 'HR_APP',
        p_message  => 'FATAL: Conexiune eșuată către serverul de salarii.',
        p_level    => debug_utils.g_log_levels(5)  -- FATAL
    );
END;
/
BEGIN
    debug_utils.log_error(
        p_app_name  => 'HR_APP',
        p_proc_name => 'test_error_case',
        p_err       => 'Eroare de validare: valoare negativă detectată.'
    );
END;
/



